##### ***Mutation testing of PL/SQL programs***

**分类：其他应用-PL/SQL程序测试**

​		目前的许多变异测试工具主要适用于一些如C和Java的主流语言程序，由于这些工具的一个关键元素是变异运算符列表（它定义了修改源代码和生成变异的方式），这些变异运算符本质上是特定于编程语言的，因此能用于一些小众语言的变异测试工具并不多。

​		本实验就针对 PL/SQL (Procedural Language/Structured Query Language)，这一业界采用的但很少被研究关注的动态编程语言（尽管很多在Oracle数据库管理系统上工作的企业级应用都使用该语言实现），设计了一种变异测试工具，muPLSQL，来帮助变异的生成和测试执行的自动化。具体的，本实验提出了44个适用于PL/SQL的变异运算符，其中17个用于PL，21个用于SQL，6个专门用于PL/SQL。同时还将此工具设计为可扩展的，用于合并新的变异运算符。

​		为了评估该工具和变异测试的适用性和有用性，本实验还进行了一个工业案例研究，使用muPLSQL对业务支持软件系统进行变异测试和分析。研究中使用了系统的19个对象，共包含了8206行PL/SQL代码。最终muPLSQL总共产生了5939个变异体，存活变异体数量为680，PL/SQL特异性变异算子产生了320个变异体，其中46个在测试执行中存活。对活变种的手动检查发现，有112个缺失的测试场景和数据验证应纳入现有测试套件。此外，在检查过程中发现了8个源代码错误。



***Efficient Active Automata Learning via Mutation Testing***

**分类：其他应用-主动自动机学习**

​		自从证明主动自动机学习(active automata learning)可以提供黑箱系统的模型来实现形式验证，这种学习已经成为形式方法研究的一个活跃领域。由于模型学习与测试有着密切的关系，因此它在测试社区中也很受欢迎，导致了与基于模型的测试的各种组合的发展。在主动自动机学习中存在着两种查询，成员查询(membership queries)和等价查询(equivalence queries)。成员查询对于学习黑盒系统很容易实现（通常只需重置系统、执行单个测试并记录观察结果即可）。而等价查询则更难实现，一些研究提出了一致性测试算法，但这些算法存在两个问题，一是要求要求黑盒系统的状态数有一个固定的上限（通常是未知的），二是构建的测试套件的大小在这个范围内是指数级的。因此实现等价预言可以被视为自动机学习的真正瓶颈。

​		本实验提出了一种基于变异测试的等价查询的实现，更具体地说是基于模型的变异测试，其基于新的目标不是试图证明等价性，而是快速找到反例的思想，尽量减少执行等价查询的测试次数。本实验将随机测试与变异分析相结合，以实现测试的高变异性，并适当解决覆盖率问题。

​		为了证明其有效性，本实验将该方法应用于学习实验，并将其性能与成熟的测试技术——部分W方法进行比较。该评估表明，该方法显著降低了学习成本。在多次实验中，将成本降低了至少一个数量级。



***Mutation Testing of Quantum Programs: A Case Study With Qiskit***

**分类：其他应用-量子程序测试**

​		量子计算使用量子比特（Quantum bit）作为其基本单位，而不是经典计算比特。虽然经典比特只能呈现两种基本状态中的一种（例如，0或1），但量子比特可以呈现这些基本状态的叠加，理论上允许量子比特比相同数量的经典比特持有指数级更多的信息。虽然快速普及量子计算机势必会打破几十年来一直存在的若干计算限制，但它也势必会给许多计算机科学学科带来重大挑战，例如软件测试。尽管在经典计算领域，测试已经得到了广泛的研究，并提出了许多方法和工具，但量子程序（quantum programs, QPs）的此类方法仍处于起步阶段，大多数熟悉经典世界的程序员，更容易在反直觉的量子编程中犯错误。其中一个问题就是，QPs必然是概率性的，不可能在不中断执行或不影响其结果的情况下进行检查。因此，在量子计算领域，确保QPs的正确实现更加困难。

​		变异测试已被证明是改进测试实践的有效技术，有助于保证程序的正确性，因而被很容易想到将其应用于量子计算领域，本实验旨在研究变异测试在真实QPs上的应用，重点研究最流行的用于量子计算的开源全栈库，IBM的量子信息软件包（Qiskit）。Qiskit是首批公开发布的量子软件开发工具包之一，它提供了在IBM Quantum Experience基础设施上的原型量子设备或本地计算机上的模拟器上开发和运行QPs的工具。简而言之，Qiskit将用Python编写的QPs转换为一种称为OpenQASM的量子指令语言。

​		本实验利用语法等效门的概念，提出了五个为QPs定制的新颖的变异算子；以及一个新的基于Python的可以自动执行QPs的变异测试的工具集，名为QMutPy，并且完成了其在24个真实QPs上的有效性和效率的实证评估；同时还详细讨论了如何扩展QPs测试套件以杀死更多的变异体，从而检测更多的bug。

​		实验结果表明，QMutPy可以生成揭示错误的量子变异体，并暴露在实验中使用了真实QPs的测试套件中出现的一些问题。本实验讨论了测试套件的两个改进，即增加代码覆盖率和提高测试断言的质量。这样的改进显著增加了测试套件的变异得分，从而可开发出更高质量的QPs。



***An Improved Crow Search Algorithm for Test Data Generation Using Search‑Based Mutation Testing***

**分类：引导测试生成-测试数据自动化生成**

​		在软件测试中，测试用例可以定义为一组输入，并开发执行先决条件来验证特定需求是否得到满足，能够满足测试目标的测试用例集称为有效测试套件。手动生成测试用例是一项复杂而又昂贵的任务，自动测试用例生成被认为是手动测试用例生成的一种替代方法，因为它可以减少过程中涉及的成本和时间。

​		变异测试是软件行业用来验证被测软件质量的一种流行方法。在变异测试中，将错误（错误是程序员可能犯的错误）添加到原始程序中，以创建变异代码。将相同的测试用例应用于原始代码和变异代码来进行，如果测试用例发现原始程序和变异程序之间存在差异，则称变异程序被杀死或检测到。相反，当测试用例无法找到差异时，变种被认为是活的。所产生的变异体数量可能太多，其中许多变异体可能相当，也可能被简单地杀死。基于变异测试的测试数据生成的重点是找到能够杀死最大数量非等效变异的测试套件。

​		在过去，大多数关于变异测试的研究工作都集中在寻找非科学软件中的缺陷。所提出的方法旨在借助生物启发算法来改进过程，以识别科学代码中的变异体。科学软件依赖于输出的准确性而不是正确性。因此，一般的变异测试不足以发现错误，因为科学软件即使对小的舍入误差也很敏感，其中错误可能是以掩蔽形式出现的。本文中使用的基于搜索的技术是一种改进的Crow Search Algorithm（CSA）用于生成测试数据。 在CSA中，搜索模式取决于称为飞行长度的独立参数。这可能导致搜索解决方案被困在本地区域内的问题。因此，提出的改进的ICSA方法为每个测试用例生成柯西随机数，以防止搜索陷入局部搜索，因此解决了CSA中的一些限制。



***Effective Fault Localization via Mutation Analysis: A Selective Mutation Approach*** 

**分类：缺陷定位**

​		缺陷程序位置的识别通常被称为故障定位过程，并表示在给定一组测试的情况下定位软件故障的问题。这构成了一个困难的问题，结果是调试活动中最昂贵的过程之一。研究人员已经投入了大量精力来自动化故障定位活动，从而减少其费用。

​		最近，提出了一种基于变异分析的缺陷定位方法。我们称这种方法为基于变异的方法。尽管变异分析最初是为了测试而提出的，但其已被证明在各种背景和应用中都是有用的，就比如缺陷定位。初始结果表明基于变异的方法比基于语句的方法能更好地定位缺陷。变异方法背后的直觉是，当失败的测试用例能够杀死变种，而通过的测试用例却让它们存活时，它们的位置指示了导致测试失败的位置。按照这些思路，本文考虑了Papadakis和Le Traon提出的基于变异的方法，并将其与最先进的基于频谱的故障定位方法进行了比较，结果表明基于变异的缺陷定位优于其他研究的方法。

​		尽管有效，但应用变异分析需要大量的计算资源。为了解决这个问题，研究人员提出了各种变异技术，如变异取样和选择性变异。 本文将选择性变异这种技术，应用于缺陷定位问题。实验结果表明，本文提出的选择性变异方法能够将涉及的变异数目减少80%，而不会损失缺陷定位精度。因此，该方法的计算需求大大减少。



***Ask the Mutants: Mutating Faulty Programs for Fault Localization***

**分类：缺陷定位**

​		故障定位在整个调试活动中是一个昂贵的阶段，因为它通常需要人工努力来理解被测程序（PUT）的复杂内部逻辑，以及通过和失败测试运行之间的差异。因此，自动故障定位技术得到了广泛的研究。一种这样的技术是基于频谱的故障定位（SBFL）。它使用程序谱，即测试套件执行的概要，根据预测的包含故障的风险对程序语句进行排序。然后，开发人员将按照给定排名中语句的顺序检查被测程序，希望在排名顶部附近会遇到错误语句。然而，它因其不切实际的准确性和不现实的使用模型（即排名的线性检验）而受到批评。

​		本文提出了一种新的故障定位技术MUSE，即基于变异的故障定位方法。MUSE使用变异分析来唯一地捕捉单个程序语句和观察到的故障之间的关系。它不受来自块结构的共享排名的强制。本文关注的是当改变一个已经有错误的程序时会发生什么。直观地说，由于错误的程序可以通过修改错误的语句来修复，因此修改错误的语句将使更多失败的测试用例通过，而不是修改正确的语句。相比之下，改变正确的语句将使更多通过的测试用例失败。这是因为改变正确的语句会引入新的错误语句，而不是PUT中现有的错误语句。这两个观察结果构成了故障定位新度量设计的基础。

​		我们还为故障定位技术提出了一种新的评估指标，LIL（Locality Information Loss，位置信息损失），其利用信息理论，通过定位技术测量断层的真实位置和预测位置之间的信息损失。它可以应用于任何故障定位技术，并描述任意数量故障的定位。使用传统的费用指标和LIL，本实验针对五个真实世界程序的14个错误版本评估MUSE。结果表明，平均而言，MUSE比目前最先进的SBFL技术Op2准确约25倍。



***Metallaxis-FL: mutation-based fault localization***

**分类：缺陷定位**

​		故障定位方法试图基于失败和通过的测试执行提供的信息来识别错误的程序语句。基于频谱的方法是最流行的方法之一，其是通过根据程序语句出错的概率为其指定可疑值来帮助程序员。

​		变异分析通过在所分析的程序中引入名为变异的缺陷来工作，其依赖于这样的假设，即大多数变异体都会形成“真实”的缺陷，即使是人工播种的。因此，可以定位以下问题：如果变异体的检测结果揭示了“未知”故障，那么变异体的定位是否能够帮助定位这些故障？本文研究了这个问题，并最终建议使用变异分析进行故障定位。通过利用变异作为结构代码覆盖的替代，可以定义一种新的基于变异的故障诊断方法。这意味着变异分析可以协调测试和诊断活动，这些活动通常针对不同的目标，如故障检测和故障定位。

​		本文提出了一种基于变异分析的故障定位方法Metallaxis。Metallaxis的创新之处在于它使用了变异体，并将它们与错误的程序位置联系起来。因此，大部分因测试失败而死亡的变异体提供了一个关于故障位置的良好指示。使用Metallaxis的实验表明，它比基于语句的方法更有效。即使在有助于降低变异成本的技术（如变异采样）的情况下，这也是正确的。此外，受控实验的结果表明，使用变异作为测试技术有利于故障定位过程。因此，通过使用基于变异的测试而不是基于块或基于分支的测试套件，可以显著改进故障定位。最后，还提供了支持方法可扩展性的证据。

​	

***DeepMutation++: a Mutation Testing Framework for Deep Learning Systems***

**分类：AI测试-深度神经网络DNN**

​		深度神经网络（DNN）在自动驾驶、机器翻译、医疗保健和机器人等许多应用领域取得了巨大成功。一般来说，当前最先进的DNN可以大致分为前馈神经网络（Feed-Forward Neural Network，FNN）和递归神经网络（Recurrent Neural Network，RNN）。

​		然而，DNN的测试要求很高，尽管有一些初步研究可用，但目前DNN的检测仍处于早期阶段，面临许多挑战性问题。测试工具支持可能是促进解决这些挑战的解决方案探索的一个重要因素。

​		遵循传统软件变异测试的类似精神，本文介绍了DeepMutation++，一个用于FNN和RNN的变异测试框架。DeepMutation++为DeepMulation中引入的FNN模型引入了八个模型级算子，并进一步提出了九个专门用于RNN模型的新算子。特别是，为了迎合RNN的特点，DeepMutation++支持静态变异生成以整体分析测试数据，以及动态变异生成以在运行时检测测试输入的脆弱片段。与DNN的结构覆盖标准不同，DeepMutation++能够直接提供关于DNN对输入的鲁棒性的反馈。直观地说，接近神经网络决策边界的输入相对难以被DNN鲁棒地处理。因此，在区分DNN和生成的变异体的行为时对测试数据的分析能够评估DNN的稳健性，以及在潜在触发DNN的脆弱决策行为时测试数据的质量。

​		本文证明了DeepMutation++在DNN稳健性分析和测试数据脆弱片段检测的两个典型场景中的有用性：1）基于MNIST数据集的FNN（即LetNet-5）图像处理，2）基于IMDB数据集的RNN（即LSTM和GRU）文本情感分析。本文报告了此框架在DNN变异产生中的效率以及鲁棒性分析结果。还发现，基于变异测试定义的度量可以是DNN鲁棒性的一个重要指标，与DNN抵抗对抗性攻击的鲁棒性有很强的相关性。



***Detecting Adversarial Samples for Deep Neural Networks through Mutation Testing***

**分类：AI测试-深度神经网络DNN**

​		近年来，深度神经网络(DNN)已经有了广泛的应用，并在解决问题方面取得了极大的成功。然而，也有研究表明，即使是训练有素的DNN也容易受到对抗样本(adversarial samples)的攻击，尤其是当DNN应用于分类任务时。对抗样本通常是通过对抗性扰动来制作的（即对原始样本进行细微修改，使DNN模型对样本进行错误标记），而这样的制作很容易完成。

​		随着DNN越来越多地用于自动驾驶汽车等安全关键系统，开发有效的技术来防御此类攻击至关重要。现有的防御策略主要集中于增加攻击者制作对抗样本难度和基于训练辅助模型检测对抗样本两个思路进行，然而这些防御策略依赖于可用的对抗样本，因此通常仅限于防御特定攻击。

​		本实验观察到，对抗样本比正常样本对随机扰动更敏感，即对对抗样本施加随机扰动获得不同标签的概率明显高于对正常样本施加随机干扰的概率。因此本实验提出了一种在运行时有效检测对抗样本的方法：nMutant，该方法收到了软件工程界开发的变异测试的启发，主要思想是测量所提供的样本对随机扰动的敏感程度，并在灵敏度高于某个阈值时发出警报，以此来检测并防御对抗样本的攻击。该方法不需要任何底层DNN系统的知识，因此可以潜在地应用于广泛的系统。与现有的防御策略相比，它具有合理的可扩展性和可靠性。

​		经过实验表明，nMutant能够有效地检测到由最近提出的攻击方法生成的大多数对抗样本。此外，还提供了一个具有一定统计意义的误差范围以及检测结果。



***Mutation Testing for Artificial Neural Networks: An Empirical Evaluation***

**分类：AI测试-深度神经网络DNN**

​		近年来，人们对利用源自人工智能的方法和技术来提供扩展功能越来越感兴趣。在本文中，重点是研究变异测试在神经网络背景下的适用性。值得注意的是，我们专注于某些编程语言（如Java）的变异测试工具的使用和适用性，而不考虑神经网络专用变异工具。这一决定背后有三个原因。首先，神经网络和其他来自人工智能的方法和工具被嵌入到更传统的系统和软件中，因此，当作为一个整体测试此类系统和软件时，我们必须依赖可用的工具。其次，软件工程工具越来越紧密地集成到开发过程中，这使它们易于使用。最后，我们感兴趣的是从软件工程的角度来检查利用测试数据评估神经网络是否足够。

​		因此，我们考虑了不同的神经网络实现，并利用可用的变异测试工具进行了实验评估，以检查是否可以使用普通的变异测试（即，未用于神经网络的变异测试）来获得关于测试这些神经网络实现的程度的有价值信息。特别是，我们利用了神经网络的评估方法，其中我们利用可用的测试数据来计算变异分数，即检测到的变异和神经网络库实现中引入的所有变异的分数。此外，我们研究了测试数据的大小对变异得分的影响。

​		本文主要介绍了一种在考虑神经网络评估的神经网络背景下使用变异测试的方法。并且讨论实验评估，回答依赖于用于评估的测试数据的神经网络实现的变异测试是否足以确保这些实现的正确性的问题。

​		
